#lang sicp

(define (map func lst)
  (if (null? lst) '() (cons (func (car lst)) (map func (cdr lst)))))
(define (for-each func lst)
  (if (not (null? lst))
      (begin
        (func (car lst))
        (for-each func (cdr lst)))))

; Mutant pairs
(define y (list 'a 'b))
(define x (list y y))

; Q1
y ; -> (a b)

; Q2
x ; -> ((a b) (a b))

; Q3
; (c)
#|
(define x (cons 'x (cons 'x '())))
(define y '())
(let ((z (list 'a 'b)))
          (set-car! x z)
          (set-car! (cdr x) z)
          (set! y z))
|#

; Q4
(set-cdr! (cdr x) (cdr (car x)))
x ; -> ((a b) (a b) b)

; Get it together
(define foo (list 1 2 3))
(define bar (list 4 5 6))
(define (append! lst1 lst2)
  (let ([rear-ptr (cddr lst1)])
    (begin
      (set-cdr! rear-ptr lst2)
      lst1)))

(define baz (append! foo bar))
baz ; -> (1 2 3 4 5 6)
foo ; -> (1 2 3 4 5 6)

; Advantages : Time, Space , Disadvantages : Not easy to debug
(define foo2 (list 1 2 3))
(define bar2 (append! foo2 foo2))
bar2 ; -> #0=(1 2 3 . #0#) (Cycle)

; Coming or going?
(define (reverse! lst)
  (define (goback _)
    (let ((front (car lst)))
      (begin
        (display lst)
        (newline)
        (set-cdr! (cddr lst) (car lst))))
  (begin
    (for-each goback lst)
    lst)))
(define foo3 (list 1 2 3 4))
(define bar3 (reverse! foo))
foo3
bar3
